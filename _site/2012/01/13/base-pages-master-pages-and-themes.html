<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Base Pages, Master Pages, and Themes</title>
	<meta name="description" content="I enjoy programming stuff - up to and including things!">
	<meta name="author" content="Brian Scaturro">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link href='http://fonts.googleapis.com/css?family=Anton' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" href="/css/base.css">
	<link rel="stylesheet" href="/css/skeleton.css">
	<link rel="stylesheet" href="/css/layout.css">
	<link rel="stylesheet" href="/css/pygments.css">
	<link rel="shortcut icon" href="/images/favicon.ico">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>	
<body>
	<div class="container">
		<div class="eleven columns alpha">
			<header id="branding">
				<a href="/">
					<div class="site-heading">Brian Scaturro</div>
					<div class="site-subheading">Fancy a dance?</div>
				</a>
			</header>
			<div id="main" role="main">
				<article class="eleven columns alpha">
					<h1>Base Pages, Master Pages, and Themes<span class="post-date">13 Jan 2012</span></h1>
					I have kind of grown tired of prefixing all these posts with "30 Days of ASP.NET". The bright blue bar should be more than enough to show this fella belongs to a post series. In the last entry, I went over some basics of form processing with C# and ASP.NET web forms. One very cool aspect of ASP.NET is the concept of master pages and themes. These are two tools that are indispensable when it comes to creating a consistent look and feel for your web application. The concept of a base page will illustrate creating a consistent <code>Page</code> class for all of your web forms to inherit from. Let's do this!

Please feel free to download the source to get a more in depth look at the code and styles used.
<div class="tags Yellow">
<a class="add-bottom" href="/downloads/pizzagreeta.zip" title="download source">Download Source</a>
</div>
<hr />

<h3>Creating Consistent Functionality With Base Pages</h3>
An important concept in any object oriented language is inheritance. C# is no exception. If you have been hackin away at some web forms lately, you should probably notice that all of your code-behind files have classes that extend the <code>System.Web.UI.Page</code> class.
<pre class="prettyprint">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

public partial class _Default: System.Web.UI.Page
{
    //..methods and properties
}
</pre>
As you can see, extension is accomplished via the colon (:).

The idea behind a base page is creating a class that extends the <code>System.Web.UI.Page</code> class. Instead of inheriting from the <code>System.Web.UI.Page</code> class, your pages will all inherit from the custom <code>BasePage</code> class.

<h4>Creating A BasePage Class</h4>
If you haven't already, and since we are working in a "Web Site" project, right click the project name in the solution explorer and follow <code>Add ASP.NET Folder > App_Code</code>.
<img src="http://www.brianscaturro.com/wp-content/uploads/2012/01/app_code.jpg" alt="adding the app_code folder" title="adding the app_code folder" width="616" height="283" class="alignnone size-full wp-image-1430" /> Right click the new <code>App_Code</code> folder and click "Add New Item". Add a class and name the file BasePage.cs.

<h4>Extending The System.Web.UI.Page Class</h4>
The idea here is to have our <code>BasePage</code> extend <code>System.Web.UI.Page</code> so that our pages don't have to. We will start out with nothing and build on it as we need to share more functionality. For now take a look at how this extension is accomplished:
<pre class="prettyprint">
using System;
using System.Web;
public class BasePage : System.Web.UI.Page
{
    public BasePage()
    {
    }
}
</pre>
Voila! Our BasePage is created. For now we just have an empty constructor, but we will build on this. Our pages can now inherit from this instead of the typical <code>System.Web.UI.Page</code> class.

<h3>Creating a Consistent Layout With Master Pages</h3>
If you want to create a consistent layout for your web forms, then you will definitely need a master page or two. You can place site wide styles and controls in these bad boys. Master pages are a lot like aspx pages in that they can contain server controls and they also have their own code-behind file. The key player in a master page is the <code>ContentPlaceHolder</code> control. This guy does exactly what it's name implies; it acts as a placeholder for content. I created a directory in the solution called "MasterPages" to place my master pages. Here is the master page "Layout.master" that will be used for the remainder:
<pre class="prettyprint">
&lt;%@ Master Language="C#" EnableViewState="true" ViewStateMode="Disabled" AutoEventWireup="true" CodeFile="Layout.master.cs" Inherits="MasterPages_Layout" %&gt;

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;

&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head runat="server"&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;asp:ContentPlaceHolder id="head" runat="server"&gt;
    &lt;/asp:ContentPlaceHolder&gt;
    &lt;link href="../styles.css" rel="stylesheet" type="text/css" /&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form id="form1" runat="server"&gt;
    &lt;div id="topHat" class="add-bottom"&gt;
        &lt;div class="wrapper clearfix"&gt;
            &lt;div class="alignleft"&gt;
                &lt;a href="Default.aspx"&gt;Home&lt;/a&gt;
            &lt;/div&gt;
            &lt;div class="alignright"&gt;
                &lt;asp:Label AssociatedControlID="ddlThemes" ID="lblThemes" runat="server" EnableTheming="false" Text="Choose Theme: "&gt;&lt;/asp:Label&gt;
                &lt;asp:DropDownList ID="ddlThemes" runat="server" AutoPostBack="true" 
                    onselectedindexchanged="ddlThemes_SelectedIndexChanged" ViewStateMode="Enabled" EnableTheming="false"&gt;
                    &lt;asp:ListItem&gt;Grid&lt;/asp:ListItem&gt;
                    &lt;asp:ListItem&gt;Midnight&lt;/asp:ListItem&gt;
                &lt;/asp:DropDownList&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="wrapper"&gt;
        &lt;asp:ContentPlaceHolder id="ContentForLayout" runat="server"&gt;
        
        &lt;/asp:ContentPlaceHolder&gt;
    &lt;/div&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
As you can see, things look pretty similar to a web form. You will notice that instead of the &lt;@ Page &gt; directive, there is a &lt;@ Master &gt; directive.

<h4>Using Master Pages In Web Forms</h4>
It is super easy to use a master page in web forms. In the Default.aspx file , you just need to reference the Master Page via the <code>MasterPageFile</code> property of the &lt;@ Page &gt; directive. If your web form is in the root of your web site, and the master page is in the MasterPages directory, the directive will look like the following:
<pre class="prettyprint">
&lt;%@ Page Language="C#" MasterPageFile="~/MasterPages/Layout.master" AutoEventWireup="true" CodeFile="Default.aspx.cs" Inherits="_Default" %&gt;
</pre>
The next step is to make sure that the content from your web form ends up in the placeholder of the master page. This is accomplished with the <code>Content</code> control. Simply wrap the content of your web form in the .aspx file in this control:
<pre class="prettyprint">
&lt;asp:Content runat="server" ContentPlaceHolderID="ContentForLayout"&gt;
    &lt;!-- web form content here --&gt;
&lt;/asp:Content&gt;
</pre>
The thing to notice here is that the <code>Content</code> control has a property called <code>ContentPlaceHolderID</code> that refers to the <code>ID</code> property of our master page's <code>ContentPlaceHolder</code> control. This is how the ASP.NET run time knows to place the web form's content inside the master page.

<h3>Creating a Consistent Look With Themes</h3>
We have consistent functionality, consistent layout, and now we need a way to have a consistent style for our application. This is accomplished with Themes. Much like adding the App_Code directory, if you don't have an App_Theme folder already, right click the project name in the solution explorer and follow <code>Add ASP.NET Folder > Theme</code>.
<img src="http://www.brianscaturro.com/wp-content/uploads/2012/01/themes.jpg" alt="adding themes to an ASP.NET project" title="adding themes to an ASP.NET project" width="630" height="265" class="alignnone size-full wp-image-1440" /> Name your theme what ever you want. I did this twice and created two different themes, one called "Midnight" and one called "Grid"

<h4>Theme CSS</h4>
After creating a theme, you should add the necessary style sheet(s) to the theme folder (right click > Add New Item > Style Sheet). It is good practice to name the style sheet after the theme, so if my theme is called "Grid", then I should add a style sheet named Grid.css. It is also a good idea to add an images folder for your style sheet to reference if it makes use of background images.

<h4>Skins</h4>
Another key component of themes is the skin. Skins are files that end in the .skin extension and they are used to "skin" or style controls types in your project. If we want to add a CssClass to every button in our project and style it accordingly in the theme style sheet we would "right click Add New Item" a skin file, and name it something appropriate - say Button.skin. In the skin file we place the control to skin in a web form or master page - much like we would in a web form - only we leave out the <code>ID</code> property.
<pre class="prettyprint">
&lt;asp:Button runat="server" CssClass="pizza-button" /&gt;
</pre>
There are more properties you can add in the skin file, but the <code>CssClass</code> property is the most useful as far as consistent aesthetics go for a type of control. Essentially any property supported by skins that is added to this skin file, will be reflected in all the <code>Button</code> controls that show up in your application.

After adding a style sheet, an images directory , and a few skins to my "Grid" theme, my directory structure resembles the following:
<img src="http://www.brianscaturro.com/wp-content/uploads/2012/01/Screenshot_41.jpg" alt="directory structure" title="directory structure" width="286" height="352" class="alignnone size-full wp-image-1442" />

<h3>Making a Theme Switcher</h3>
Let's put this all together to make a global theme switcher. I have created two themes for my application, one called "Grid" and the other called "Midnight". I want to create a simple way for users to select their preferred theme, and have that theme be selected on their next visit. We are going to combine what we know about base pages, master pages, and themes to accomplish this task.

<h4>Adding The Theme Drop Down</h4>
The first thing we need to do is add a way for our users to select their theme. The best candidate for the job is a <code>DropDownList</code> control. Since this <code>DropDownList</code> needs to be available on every page, we will add this control to our master page. Right under the opening form tag in our master page, we will add this control with some attributes for the CSS and a couple of control properties. I will add <code>ListItem</code> controls for the two available themes.
<pre class="prettyprint">
&lt;div id="topHat" class="add-bottom"&gt;
    &lt;div class="wrapper clearfix"&gt;
        &lt;div class="alignleft"&gt;
            &lt;a href="Default.aspx"&gt;Home&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class="alignright"&gt;
            &lt;asp:Label AssociatedControlID="ddlThemes" ID="lblThemes" runat="server" EnableTheming="false" Text="Choose Theme: "&gt;&lt;/asp:Label&gt;
            &lt;asp:DropDownList ID="ddlThemes" runat="server" AutoPostBack="true" 
                onselectedindexchanged="ddlThemes_SelectedIndexChanged" ViewStateMode="Enabled" EnableTheming="false"&gt;
                &lt;asp:ListItem&gt;Grid&lt;/asp:ListItem&gt;
                &lt;asp:ListItem&gt;Midnight&lt;/asp:ListItem&gt;
            &lt;/asp:DropDownList&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre>
Notice the properties used in our two controls. The <code>Label</code> and the <code>DropDownList</code> both have a property <code>EnableThemeing</code> set to false. Since these are controls that will be present on all pages, we don't want the theme to control how they look. The <code>DropDownList</code> sets the <code>AutoPostBack</code> property to true in order to wire up a little JavaScript that will submit the form automatically when the value changes. If you look at the &lt;%@ Master &gt; directive in our master page, you will see that by default we disable view state. This is a performance consideration, but we do want our theme switcher to track it's state, so we set the <code>DropDownList</code> property <code>ViewStateMode</code> to true.

I use the global style sheet (styles.css) that I added to the <code>head</code> element of the master page to style this top section, and this is what I end up with:
<img src="http://www.brianscaturro.com/wp-content/uploads/2012/01/dropdown.jpg" alt="theme drop down" title="theme drop down" width="589" height="51" class="alignnone size-full wp-image-1447" />
<h5>Handling The Drop Down Event</h5>
Remember we set the <code>AutoPostBack</code> property to true, so whenever the value of our control changes, we need some code to handle that event. Since master pages have code-behinds of their own, this is the place to do it. Notice our <code>DropDownList</code> control has an <code>onselectedindexchanged</code> property set to the method <code>ddlThemes_SelectedIndexChanged</code>. We head to the "Layout.master.cs" file and add the following method:
<pre class="prettyprint">
protected void ddlThemes_SelectedIndexChanged(object sender, EventArgs e)
{
    HttpCookie userTheme = new HttpCookie("UserTheme")
    {
        Expires = DateTime.Now.AddMonths(3),
        Value = ddlThemes.SelectedValue
    };
    Response.Cookies.Add(userTheme);
    Response.Redirect(Request.Url.ToString());
}
</pre>
The purpose of this method is to take the selected value from the themes list and store it in a cookie. As you can see this cookie is set to expire in 3 months. After the cookie has been added to the <code>Response.Cookies</code> collection, we redirect the user to the URL where the post happened (this will server the purpose of "refreshing" the theme).

In addition to this method that handles the <code>DropDownList</code> changing values, it would be nice to make sure the control is loaded with the correct theme already selected in the control. We will do this on every page when it loads with the <code>Load</code> event. This is as easy adding some logic to the <code>Page_Load</code> method.
<pre class="prettyprint">
protected void Page_Load(object sender, EventArgs e)
{
    if (!Page.IsPostBack)
    {
        string selectedTheme = Page.Theme;
        HttpCookie userTheme = Request.Cookies.Get("UserTheme");
        if (userTheme != null)
        {
            selectedTheme = userTheme.Value;
        }
        if (!string.IsNullOrEmpty(selectedTheme) && ddlThemes.Items.FindByValue(selectedTheme) != null)
        {
            ddlThemes.Items.FindByValue(selectedTheme).Selected = true;
        }
    }
}
</pre>
First we make sure the page load does not come after a POST request. We use the default theme set for our pages (set in the web.config specifically) as our initial value for the selected theme. We then check to see if a cookie exists for the user's preferred theme, and if it does we make sure there is a corresponding value in the <code>DropDownList</code>. If everything checks out, the <code>DropDownList</code> will have the user's preferred theme already selected in the <code>DropDownList</code> control.

<h4>Using The Base Page To Display The Theme</h4>
We need to make sure the theme is loaded on every page. The best way to do this is through our <code>BasePage</code> class we created earlier. We will define some methods and make sure they get added as event handlers to every page that inherits from <code>BasePage</code>. Let's open BasePage.cs and get to work.

<h5>Loading The Selected Theme</h5>
Every page needs to load the theme that has been selected. Themes need to be set early in the ASP.NET page life cycle. The place to do it is the <code>PreInit</code> event. We need to define a method that will check the cookie we set in our master page code-behind and set the current page theme to that selected theme if it exists.
<pre class="prettyprint">
private void Page_PreInit(object sender, EventArgs e)
{
    HttpCookie userTheme = Request.Cookies.Get("UserTheme");
    if (userTheme != null)
    {
        string themePath = Request.PhysicalApplicationPath + "App_Themes" + '\\' + userTheme.Value;
        if (Directory.Exists(themePath))
        {
            Page.Theme = userTheme.Value;
        }
    }
}
</pre>
First we see if the cookie exists. If it does we use a little <code>System.IO</code> to verify that the theme directory exists. If it does we set the <code>Page.Theme</code> property to the selected theme.

We wire up the event in our <code>BasePage</code> constructor.
<pre class="prettyprint">
public BasePage()
{
    //append our Page_PreInit method to the list of handlers
    this.PreInit += new EventHandler(Page_PreInit);
}
</pre>

<h5>Loading Google Web Fonts</h5>
I wanted to use some Google Web Fonts in my application, so I have opted to do it in the <code>BasePage</code> class depending on the current theme. This is done during the <code>Load</code> of the page.
<pre class="prettyprint">
private void Page_Load(object sender, EventArgs e)
{
    //the theme was set before this in PreInit
    string selectedTheme = Page.Theme;
    if (!string.IsNullOrEmpty(selectedTheme))
    {
        switch (selectedTheme)
        {
            case "Grid":
                AddStyleSheet("http://fonts.googleapis.com/css?family=Droid+Sans|Lobster");
                break;
            case "Midnight":
                AddStyleSheet("http://fonts.googleapis.com/css?family=Open+Sans|Oswald");
                break;
        }
    }
}
</pre>
<code>AddStyleSheet</code> is a helper method used to dynamically add style sheets to the <code>Header</code> object.
<pre class="prettyprint">
private void AddStyleSheet(string href)
{
    HtmlLink link = new HtmlLink();
    link.Attributes.Add("rel", "stylesheet");
    link.Attributes.Add("media", "all");
    link.Attributes.Add("href", href);
    link.Attributes.Add("type", "text/css");
    Header.Controls.Add(link);
}
</pre>
As with our <code>Page_PreInit</code> method, we need to add our <code>Page_Load</code> method to the list of <code>Load</code> event handlers. This is done in the constructor as well.
<pre class="prettyprint">
public BasePage()
{
    this.Load += new EventHandler(Page_Load);
    this.PreInit += new EventHandler(Page_PreInit);
}
</pre>

<h5>Extending The Base Page</h5>
To make sure our pages are taking advantage of this functionality, we need to make sure the code-behind class is extending our <code>BasePage</code> instead of <code>System.Web.UI.Page</code>
<pre class="prettyprint">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

public partial class _Default : BasePage
{
    //page code
}
</pre>

<h4>Voila!</h4>
Our theme switcher is now complete. We can now switch between our two themes with ease!
<div class="columns five">
<a href="http://www.brianscaturro.com/wp-content/uploads/2012/01/grid.png"><img src="http://www.brianscaturro.com/wp-content/uploads/2012/01/grid-300x285.png" alt="grid theme" title="grid theme" width="300" height="285" class="alignnone size-medium wp-image-1457" /></a>
</div>
<div class="columns five">
<a href="http://www.brianscaturro.com/wp-content/uploads/2012/01/midnight.png"><img src="http://www.brianscaturro.com/wp-content/uploads/2012/01/midnight-235x300.png" alt="midnight theme" title="midnight theme" width="235" height="300" class="alignnone size-medium wp-image-1458" /></a>
</div>

<p style="clear:both;">
Don't forget to download the source!
</p>
<div class="tags Yellow">
<a class="add-bottom" href="/downloads/pizzagreeta.zip" title="download source">Download Source</a>
</div>

				</article>
			</div>
		</div>
		<aside class="four columns omega offset-by-one" id="sidebar">
			<img class="add-bottom photo" src="/images/steed.jpg" alt="some of my best thinking occurs on unicorns">
			<h2 class="sub-heading">Recent Posts</h2>
			<ul class='posts'>
				
				<li><h3><a href="/2012/05/21/domain-driven-php.html">Domain Driven PHP</a></h3></li>
				
				<li><h3><a href="/2012/04/27/is-agile-dead.html">Is Agile Dead?</a></h3></li>
				
				<li><h3><a href="/2012/03/27/tdd-with-mock-objects-and-phpunit.html">TDD With Mock Objects And PHPUnit</a></h3></li>
				
				<li><h3><a href="/2012/03/10/javascript-masterclass-review.html">JavaScript Masterclass With Thomas Fuchs and Amy Hoy: A Review</a></h3></li>
				
				<li><h3><a href="/">The rest....</a></h3></li>
			</ul>
		</aside>
	</div>
</body>
</html>